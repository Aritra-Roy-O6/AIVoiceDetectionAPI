import base64
import os
import io
import pytest
from fastapi.testclient import TestClient
from unittest.mock import MagicMock, patch

# Mock ffmpeg dependency logic for CI/local environments without ffmpeg
# But we can't easily mock the pydub internal calls unless we patch AudioSegment.
# For this test, we assume the environment might NOT have ffmpeg, so we might fail or need to mock pydub.
# Let's write a test that mocks the `utils.audio.convert_mp3_to_wav_bytes` to return a dummy WAV.

# We need to import app after setting env vars usually, but app handles env load.
# Set dummy API KEY for testing
os.environ["API_KEY"] = "testuser123"

from app import app
from utils import audio

client = TestClient(app)

def test_health_check():
    response = client.get("/health")
    assert response.status_code == 200
    assert response.json() == {"status": "ok"}

def test_missing_api_key():
    response = client.post("/detect", json={"audio_base64": "test"})
    assert response.status_code == 403

def test_invalid_api_key():
    response = client.post("/detect", json={"audio_base64": "test"}, headers={"x-api-key": "wrong"})
    assert response.status_code == 403

def test_valid_request_mocked_audio():
    # Mocking the audio processing to avoid need for actual FFMPEG in simple unit test
    # We mock 'decode_base64_audio', 'convert_mp3_to_wav_bytes', 'load_audio_waveform', 'preprocess_waveform'
    # Actually, we can just mock 'utils.audio.convert_mp3_to_wav_bytes' and 'utils.audio.load_audio_waveform'
    
    with patch("app.convert_mp3_to_wav_bytes") as mock_convert, \
         patch("app.load_audio_waveform") as mock_load, \
         patch("app.decode_base64_audio") as mock_decode:
            
        mock_decode.return_value = b"fake_mp3_bytes"
        mock_convert.return_value = io.BytesIO(b"fake_wav_bytes")
        # Return a simple array
        import numpy as np
        mock_load.return_value = np.zeros(16000) # 1 sec silent audio
        
        # We also need the model to be loaded. The app startup event loads it.
        # Since we use TestClient, startup handlers run. 
        # We expect model/model.pkl to exist (generated by previous step).
        
        fake_b64 = base64.b64encode(b"fake_mp3").decode("utf-8")
        
        response = client.post(
            "/detect", 
            json={"audio_base64": fake_b64},
            headers={"x-api-key": "testuser123"}
        )
        
        assert response.status_code == 200
        data = response.json()
        assert "classification" in data
        assert "confidence" in data
        assert data["classification"] in ["AI_GENERATED", "HUMAN"]
        assert 0.0 <= data["confidence"] <= 1.0

def test_audio_too_large():
    # Test strict limit logic by mocking decode to raise error or just passing huge string
    pass
    # Implementation detail: we check size in decode_base64_audio
